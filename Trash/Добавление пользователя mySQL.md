99.9% наших доступов устроены следующим образом:
1) Пользователь создает тунель к нужному серверу
2) Пользователь подключается к БД через тунель

Первая часть задачи: Дать возможность пользователю делать тунели.Для этого тебе нужен его пользователь, а так же его SSH ключ.
Проверяем, есть ли у нас пользователь vasiliy.shilov; v.shilov или кто-то подобный.
Для этого в инвентаре заходим в:

```console
roles/common/.priv
```

Такого юзера нет, значит, он никогда не давал нам свой публичный ssh ключ. Значит мы не можем добавить его на сервер. Исправляем следующим образом: Идем к нему в личку и просим его публичный ключ. Создаем файл по образу и подобию здешних. По хорошему придерживаемся именования идентичного почтовому ящику.

```
vasiliy.shilov@profitclicks.info -> vasiliy.shilov -> vasiliy.shilov.pub
```

Этот ключ - часть git-репозитория. Поэтому чтобы он появился у других коллег, его надо запушить. Но перед тем как запушить, мы придерживаемся хоть какого-то подобия git flow; и работаем через ветки и мерж-реквесты. Работаем так абсолютно везде - хоть в наших репо, хоть с программистами. Особенно с программистами. Напрямую в мастер никогда не пушим.

```git checkout -b add/vasiliyshilov - #создаст нам отдельную ветку + переключится в неё
git add . #добавит в новый коммит все изменившиеся файлы в папке
git commit #зафиксирует изменения
git push --set-upstream origin add/vasiliyshilov отправит изменения на гит сервер
```
Получаем ссылку на мерж, и отправляем её старшему админу
После принятия мержа можно будет сделать:

```console
git checkout master; git pull
```

Теперь, когда у нас есть ключ в роли common; мы можем добавлять этот ключ в инвентаре и активно его использовать
Анализируем задачу: КУДА надо добавить пользователя? Ответ: adsbid, stage, mysql.
Поскольку у нас инвентарь основан на управлении группами, ищем ближайшую группу отвечающую требованиям. Группы названы по возрастающей, начиная от самого широкого круга-звена, заканчивая узким его сектором. То есть, есть группа adsbid. Она содержит настройки вообще всего адсбида.
Есть группа adsbid_stage. Она содержит настройки всего стейджа. Есть adsbid_stage_db. Она содержит настройки всех баз данных на стейдже адсбида
И наконец есть adsbid_stage_db_mdb - она содержит настройки всех баз данных mysql на стейдже адсбида. То что надо.

Гуппу в которую надо добавить пользователя нашли. Теперь куда его добавлять?
За создание unix-пользователей у нас отвечает роль common. И у неё есть 4 листа-переменных, которые можно использовать:

```
common_users
common_users_nosudo
common_users_noshell
common_additional_ssh_users
```

Если ты добавишь юзера в первый лист, то он будет иметь права SUDO на сервере. Если во второй - это будет обычный пользователь. Если третий - это будет пользователь, у которого не будет шелла (но он сможет создавать туннель!). И в четвертом листе описаны пользователи, которые были созданы не ролью, а руками.
В идеале, мы спрашиваем пользователя как бы он хотел заходить на сервер и т.д.
В реальности мы выдаем ему noshell и обучаем как пользоваться DBeaver. Потому что незачем юзеру лазить по нашим серверам, если у него нет на то реальной причины.

Добавление настолько же просто насколько написать юзернейм:

```common_users:
  - denis
  - a.sherbina
  - a.senkov
  - m.andreev

common_users_noshell:
  - v.edelkin          # Вадим Еделькин, тестировщик
  - vasiliy.shilov     # Василий Шилов, QA-лид
```


Убеждены что все правильно? Тогда запускаем роль коммон на группу серверов в которую мы его добавили - в нашем случае, adsbid_stage_db_mdb


Сначала запускаем его в check-mode; который не внесет изменений

```console
ansible-playbook --check --diff --private-key=~/.ssh/profitclicks_servers.ppk zzz_z.yml
```

Эта прокатка не внесет реальных изменений на сервер, а покажет что именно будет изменено.
Например, вот роль показала что она добавит 1 user с помощью команды useradd.
И в самом конце, при исполнения роли мы видим что все ОК.
Изменения показываются, так что мы видим что именно пошло по плану а что нет. Если нас это устраивает (а нас устраивают изменения), катим тот же плейбук, просто без режима проверки.


```console
ansible-playbook --check --diff --private-key=~/.ssh/profitclicks_servers.ppk zzz_z.yml

ansible-playbook --diff --private-key=~/.ssh/profitclicks_servers.ppk zzz_z.yml 
```

Итого через 5 минут изменения применяются, и плейбук завершает работу.

Вторая часть задачи: дать пользователю возможность подключиться к базе, впрочем она на два порядка проще.

Сводится к набору команд:

```console
mysql;

чтобы зайти в консоль мускуля.
SELECT host,user FROM mysql.user; 
чтобы посмотреть какие юзеры есть сейчас (мало ли, уже дали доступ)

SHOW DATABASES; 

#чтобы показать какие БД вообще присутствуют и спросить юзера к какой БД ему вообще нужен доступ _(в случае adsbid_stage это будет скорее всего bidnew_stage)_

GRANT SELECT ON 'bidnew_stage'.* TO 'vasiliy_shilov'@'%' IDENTIFIED BY 'password123321'; FLUSH PRIVILEGES; 

```

Ну а дальше все просто. Пароль у тебя есть, логин у тебя есть (тот же самый что и почта, просто все точки меняешь на нижнее подчеркивание. базы данных не любят точки.)